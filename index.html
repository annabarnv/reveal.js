<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background-image="./examples/assets/wine-red-lips.png">
          <aside class="notes">
            Let’s talk about the KISS principle which basically means keeping things as simple as possible to get better results.
          </aside>
          <h1 class="r-fit-text">KISS Principle</h1>
          <h2>(Keep it simple stupid)</h2>
        </section>
        <section data-auto-animate>
          <span>What does KISS stand for?</span>
        </section>
				<section data-auto-animate>
          <span style="border-bottom: 3px solid rgb(253, 55, 131) ;">What does KISS stand for?</span>
          <aside class="notes">KISS stands for Keep it simple stupid. Or formally, Keep It Simple and Straightforward.<br> It is a principle which states that a system should be designed in such a way that it’s easy to understand the internals later. As a result, making any changes will require minimum effort.
            </aside>
          <p style="font-size: 28px;" class="fragment fade-up">KISS stands for Keep it simple stupid.<br> Or formally, Keep It Simple and Straightforward.</p>
        </section>
        <section data-auto-animate>
          <span>Where did this principle come from?</span>
        </section>
				<section data-auto-animate>
          <span style="border-bottom: 3px solid rgb(253, 55, 131) ;">Where did this principle come from?</span>
          <aside class="notes">It is assumed to have originated by an aeronautical engineer named Kelly Johnson.<br>
            While making a jet aircraft as a lead engineer, Kelly guided his designers to keep the system simple enough so that anyone with a primary mechanic’s training and basic tools can repair it in a combat situation.<br>
            The principle is relevant and useful to any field that designs a system and, of course, for software engineers to design software.
          </aside>
          <img class="fragment" src="./examples/assets/Kelly Johnson.jpeg" width="800px" height="400px" alt="Kelly Johnson">
        </section>
				<section>
          <span style="border-bottom: 3px solid rgb(253, 55, 131) ;">What does KISS solve?</span>
          <aside class="notes">
            Now what the KISS principle is trying to solve is:<br>
            Untangles Complex Code, therefore making code easier to read
          </aside>
          <ul style="margin-top: 40px;">
            <li class="fragment fade-up">Untangles Complex Code, therefore making code easier to read</li>
          </ul>
        </section>
        <section>
            <span style="border-bottom: 3px solid rgb(253, 55, 131) ;">A Common KISS Code Smell</span>
            <aside class="notes">
              A Common KISS Code Smell is when you’re reading code and
              it’s either complicated or hard to follow.<br>
                Sometimes, if you find yourself asking in your mind “What’s going on”,
                “I can’t follow this code”, “I’m super confused with what I’m reading right now”,
                  then you have a good indicator that the KISS principle has been broken.<br>
                  But, maintaining a few simple patterns can make the whole experience a lot better. Let’s see some —
            </aside>
            <ul style="margin-top: 40px;">
              <li class="fragment fade-up">Complicated Code, hard to follow <span style="font-size: 32px;">(open to more than one interpretation, having a double meaning)</span></li>
            </ul>
        </section>
        <section>
          <span>Short-circuit Evaluation</span>
          <aside class="notes">
          Here we have an example of Short Circuit Evaluation.<br>
          The code above is pretty common, let’s do it smartly (click)<br>
          We can use short-circuit evaluation in many cases like - (click)<br>
          This will return the persons firstName if the person is not invalid (undefined, null, etc).
          </aside>
          <pre class="fragment fade-in"><code data-trim data-noescape>
            if (var1 === null || var1 === undefined || var1 === '') {
              console.log("VARIABLE NOT FOUND!")
          } else {
              console.log(var1)
          }
          </code></pre>
          <pre class="fragment fade-in"><code data-trim data-noescape>
          console.log( var1 || "VARIABLE NOT FOUND!" )
          </code></pre>
          <pre class="fragment fade-in"><code data-trim data-noescape>
          const firstName = person && person.firstNames
          </code></pre>
       </section>
       <section>
        <span>Arrow Functions () =></span>
        <aside class="notes">
          Ok, next example is about Arrow Functions () =><br>
          This was a trivial function, which can be replaced with arrow function<br>
          How clean it is!<br>
          WARNING: function and arrow functions have different scoping methodology. So, use them carefully.
        </aside>
        <pre><code data-trim data-noescape>
            function sayHello(name) {
              console.log('Hello', name)
          }
        </code></pre>
        <p style="font-size: 28px; text-align: start; margin-top: 40px;">can be replaced with</p>
        <pre><code data-trim data-noescape>
          const sayHello = name => console.log("Hello", name)
        </code></pre>
       </section>
       <section>
        <span>Avoid boring old for loop</span>
        <aside class="notes">
          Avoid boring old for loop (click)<br>
          I think I don’t have to describe, code speaks for itself
        </aside>
        <pre><code data-trim data-noescape>
          const list = [2, 5, 7, 2, 6, 2, 3, 5]
          for (let i = 0; i < list.length; i++) {
              console.log(list[i])
          }
        </code></pre>
        <pre class="fragment fade-in"><code data-trim data-noescape>
          list.forEach(number => console.log(number))
        </code></pre>
        </section>
        <section>
          <span>Implicit Return</span>
          <aside class="notes">
            Implicit Return (click)<br>
            When using arrow functions, we can return implicitly if the function has a single line/statement without using the return keyword.<br>
            We could return more complex values implicitly like — (click)<br>
            The code above returns an Object. Notice the braces () before curly braces {}.
          </aside>
          <pre><code data-trim data-noescape>
            function doubleValue(value) {
              return value * 2
          }
          </code></pre>
          <pre class="fragment fade-in"><code data-trim data-noescape>
            const doubleValue = value => value * 2
          </code></pre>
          <pre class="fragment fade-in"><code data-trim data-noescape>
              const getMeasures = length => ({
                area: length * length,
                volume: length * length * length
            })
          </code></pre>
         </section>
         <section>
          <span>Destructuring</span>
          <aside class="notes">
            Destructuring<br>
            The repetitive assignment work is boring, so let’s make it less-boring (click)<br>
            Now, we can also set default values here if the property doesn’t exist (click)<br>
            We can also rename some property if need to, (click)<br>
            Now, the last name will be assigned to surname
          </aside>
            <pre><code data-trim data-noescape>
              const person = {
                first: 'Wes',
                last: 'Bos',
                country: 'Canada',
                city: 'Hamilton',
                twitter: '@wesbos'
              }
              const first = person.first
              const last = person.last
            </code></pre>
            <pre class="fragment fade-in"><code data-trim data-noescape>
              let { first, last } = person
            </code></pre>
            <pre class="fragment fade-in"><code data-trim data-noescape>
              let { first = 'John' , last = 'Doe' } = person
            </code></pre>
            <pre class="fragment fade-in"><code data-trim data-noescape>
              let { first, last: surname} = person
            </code></pre>
        </section>
        <section>
        <span>Spread Operator</span>
        <aside class="notes">
          Spread Operator<br>
          Use spread operator (click)<br>
          This also works with Object types (click)<br>
          We could use spread operator anywhere (beginning, end, middle)
        </aside>
        <pre><code data-trim data-noescape>
          const odd = [1, 2, 3]
          const nums = [4, 5, 6].concat(odd)
        </code></pre>
        <pre class="fragment fade-in"><code data-trim data-noescape>
          const nums = [4, 5, 6, ...odd]
        </code></pre>
        <pre class="fragment fade-in"><code data-trim data-noescape>
          const obj1 = { a: 1, b: 2, c: 3}
          const obj2 = { …obj1, d: 4 }
          // now the obj2 will be { a: 1, b: 2, c: 3, d: 4}
        </code></pre>
      </section>
      <section>
        <span>Map, Filter, Reduce</span>
        <aside class="notes">
          Map, Filter, Reduce<br>
          Let’s imagine a scenario. We need to calculate the total distance in miles of
            all items in our distances array where distance is less than 10000 km<br>
            If we use our traditional for-loop - (click)<br>
            The code works! Now, let’s try it with map-filter-reduce (click)<br>
            See, how readable and clean the code is!
        </aside>
        <pre class="fragment fade-in" style="font-size: 18px;"><code data-trim data-noescape>
          let distances = [
            { from: 'New York', to: 'Dhaka', distance: 12654},
            { from: 'Sydney', to: 'chittagong', distance: 8858},
            { from: 'Kolkata', to: 'Sylhet', distance: 670}
          ]

          let total = 0
          for(let i = 0; i < distances.length; i++){
            if(distances[i].distance < 10000){
              total += distances[i].distance * 0.621371
            }
          }
          console.log(total)
        </code></pre>
        <pre class="fragment fade-in" style="font-size: 18px;"><code data-trim data-noescape>
          let distances = [
            { from: 'New York', to: 'Dhaka', distance: 12654},
            { from: 'Sydney', to: 'chittagong', distance: 8858},
            { from: 'Kolkata', to: 'Sylhet', distance: 670}
          ]

          let total = distances.filter(item => item.distance < 10000)
                              .map(item => item.distance * 0.621371)
                              .reduce((prev, distance) => prev + distance, 0)
          console.log(total)
        </code></pre>
      </section>
      <section>
        <span>Use descriptive names</span>
        <aside class="notes">
          Code is much easier to read when it is written with clear, descriptive function and variable names.<br>
            Here's some not-so-clear code: (click)<br>
            Its readability will be greatly improved by using meaningful variable
            and function names that reflect their meaning.(click)<br>
            Do not strive for minimalism when writing program texts.<br>
              Use full variable names that anyone who will work with your code in the future will easily understand.
        </aside>
        <pre class="fragment fade-in"><code data-trim data-noescape>
          function avg (a) {
            let s = a.reduce((x, y) => x + y)
            return s / a.length
          }
        </code></pre>
        <pre class="fragment fade-in"><code data-trim data-noescape>
          function averageArray (array) {
            let sum = array.reduce((number, currentSum) => number + currentSum)
            return sum / array.length
          }
        </code></pre>
      </section>
      <section>
        <span>Explain concepts</span>
        <aside class="notes">
          Try to code as simple as possible, unfold your concepts,
           and explain with comments where the code itself can't<br>
           Write good documentation for your code - then anyone who encounters it in the future
            will understand what and why is done in this code.
        </aside>
        <p style="font-size: 28px; text-align: start; margin-top: 40px;">Code comments should answer the “why” question.</p>
        <pre><code data-trim data-noescape>
          function areaOfCircle (radius) {
            return 3.14 * radius ** 2
          }          
        </code></pre>
        <pre><code data-trim data-noescape>
          const PI = 3.14 // Pi rounded to two decimal places

          function areaOfCircle (radius) {
            // The function implements the mathematical formula for calculating the area of a circle:
            // Pi is multiplied by the square of the circle's radius
            return PI * radius ** 2
          }
        </code></pre>
      </section>
      <section>
        <p style="border-bottom: 3px solid rgb(253, 55, 131); width: fit-content;">Complex Code Solution</p>
        <aside class="notes">
          Summing up what has been said:<br>
          To solve the KISS principle one thing is to refactor your code.<br>
          How exactly do you refactor complex code, well there is no straight or correct answer.
           Basically you just play around with other ways of writing
          code until you get to a solution that is less complex. (click)<br>
          Many principles and ideas of clean code build upon the KISS principle.
          By applying those concepts, you may find it easier to identify the simplest solution.
        </aside>
        <ul style="margin-top: 40px;">
          <li style="font-size: 28px;" class="fragment fade-up">Refactoring</li>
          <li style="font-size: 28px;" class="fragment fade-up">Learn more about Clean Code</li>
        </ul>
      </section>
      <section data-background-image="./examples/assets/pink tile.jpg">
        <span style="color: rgb(253, 55, 131); text-shadow: -1.5px 2px 2.5px rgb(69, 67, 67);">Getting Better at KISS...</span>
        <aside class="notes">
          Now again, to get good at the KISS principle considering its a vague principle,(click)
            it does take time and practice. Do not feel discouraged if you are not seeing
            a better solution to the way you’re writing code.
              The more you’re write the easier you’ll spot it in time because over time
              you’re gonna say to yourself “Wow this is really hard to read/write how can I make this easier”
        </aside>
        <ul style="margin-top: 60px;" class="fragment fade-up">
          <li style="font-size: 28px; color: rgb(39, 31, 31);">It takes time and practice</li>
          <li style="margin-top: 40px; font-size: 28px; color: rgb(39, 31, 31);">The more you program, the better your intuition will get</li>
          <li style="margin-top: 40px; font-size: 28px; color: rgb(39, 31, 31);">Do not feel discouraged if you are not seeing a better solution to the way you’re writing code</li>
        </ul>
        </section>
        <section data-auto-animate>
          <span style="color: rgb(255, 255, 255); text-shadow: 1px -2px 3px rgb(0, 0, 0); font-size: larger;">Motivation</span>
        </section>
        <section data-auto-animate>
          <p style="border-bottom: 3px solid rgb(253, 55, 131); font-size: larger;">Motivation</p>
          <aside class="notes">
            Software development principles converge to a common purpose of writing
              healthy code that can be easily read, extended, and maintained.
              KISS explicitly encourages writing simple code. (click)<br>
              If someone writes simple code, then other coders can easily read and understand that. (click)<br>
              The ability to express something plainly and simply reflects one’s own firm grasp over it.
               So, the more expressively one can code, the more proficient she/he is.<br>
               Such proficiency can be achieved by practice, experience, and most importantly, having the willingness.
              This is what the KISS principle is all about.
          </aside>
          <ul style="margin-top: 60px;">
            <li style="font-size: 28px;" class="fragment fade-up">It makes everyone’s life easy.</li>
            <li style="margin-top: 40px; font-size: 28px;" class="fragment fade-up">The more expressively one can code, the more proficient she/he is.</li>
          </ul>
        </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
        backgroundTransition: 'zoom',
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
